#!/usr/bin/env ruby
require 'unimidi'

# pads
PADS = (0..15).to_a
# button constants
SCENE = 0x10
MESSAGE = 0x11
SETTING = 0x12
NOTE_CC = 0x13
MIDI_CH = 0x14
SW_TYPE = 0x15
REL_VAL = 0x16
VELOCITY = 0x17
PORT = 0x18
FIXED_VELOCITY = 0x19
PROG_CHANGE = 0x1A
X = 0x1B
Y = 0x1C
KNOB_1_ASSIGN = 0x1D
KNOB_2_ASSIGN = 0x1E
PEDAL = 0x1F
ROLL = 0x20
FLAM = 0x21
HOLD = 0x22
PAD = 0X30

# light state constants
LIGHT_OFF = 0x00
LIGHT_ON = 0x20
LIGHT_BLINK = 0x63

# LED state constants
LED_ON = 0x00
LED_BLINK = 0x01

SYSEX_COMMON = [0xF0, 0x42, 0x40, 0x6E, 0x08]
SYSEX_NATIVE_MODE_ON = SYSEX_COMMON + [0x00, 0x00, 0x01, 0xF7]
SYSEX_NATIVE_MODE_ENABLE_OUTPUT = SYSEX_COMMON + [0x3F, 0x2A, 0x00, 0x00,
    0x05, 0x05, 0x05, 0x7F, 0x7E, 0x7F, 0x7F, 0x03, 0x0A, 0x0A, 0x0A, 0x0A,
    0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C,
    0x0d, 0x0E, 0x0F, 0x10, 0xF7]
SYSEX_NATIVE_MODE_INIT = SYSEX_COMMON + [0xF0, 0x42, 0x40, 0x6E, 0x08, 0x3F,
    0x0A, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x29, 0x29, 0xF7]
# displays YES on LED if native mode is enabled properly
SYSEX_NATIVE_MODE_TEST = SYSEX_COMMON + [0x22, 0x04, 0x00, 0x59, 0x45, 0x53, 0xF7]
SYSEX_NATIVE_MODE_OFF = SYSEX_COMMON + [0x00, 0x00, 0x00, 0xF7]

pk_in = UniMIDI::Input.find_by_name("padKONTROL").id+1
PK_IN = UniMIDI::Input.all.select{|i| i.id == pk_in}.first
pk_out = UniMIDI::Output.find_by_name("padKONTROL").id+1
PK_OUT = UniMIDI::Output.all.select{|i| i.id == pk_out}.first.open

# enable padKontrol native mode
PK_OUT.puts(SYSEX_NATIVE_MODE_ON)
PK_OUT.puts(SYSEX_NATIVE_MODE_ENABLE_OUTPUT)
PK_OUT.puts(SYSEX_NATIVE_MODE_INIT) # must be sent after SYSEX_NATIVE_MODE_ON
